# -*- coding: utf-8 -*-
"""oops

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pArzQf7OthVAIHe9YdTPvXVDDQi2CLjZ

1.	What is Object-Oriented Programming (OOP)?
A programming paradigm based on objects, which contain data (attributes) and code (methods).
	2.	What is a class in OOP?
A blueprint for creating objects; it defines attributes and methods.
	3.	What is an object in OOP?
An instance of a class; a real entity with properties and behavior.
	4.	Difference between abstraction and encapsulation?
	•	Abstraction: Hides complexity by showing only essential details.
	•	Encapsulation: Bundles data and methods, restricting direct access.
	5.	What are dunder methods in Python?
Special methods with double underscores (e.g., __init__, __str__) for operator overloading and customization.
	6.	Explain the concept of inheritance in OOP.
Allows a class (child) to inherit attributes and methods from another class (parent).
	7.	What is polymorphism in OOP?
Ability to use the same function name or operator for different types/classes.
	8.	How is encapsulation achieved in Python?
Using private/protected variables (prefix _ or __) and getter/setter methods.
	9.	What is a constructor in Python?
The __init__() method, automatically called when creating an object.
	10.	What are class and static methods in Python?

	•	Class method: Uses @classmethod; takes cls as first argument.
	•	Static method: Uses @staticmethod; doesn’t take self or cls.

	11.	What is method overloading in Python?
Python doesn’t support it directly, but can be mimicked using default arguments or *args.
	12.	What is method overriding in OOP?
Redefining a parent class method in the child class.
	13.	What is a property decorator in Python?
@property allows a method to be accessed like an attribute (getter).
	14.	Why is polymorphism important in OOP?
Increases flexibility and reusability of code by allowing different objects to be treated the same.
	15.	What is an abstract class in Python?
A class with one or more abstract methods (defined using abc module); can’t be instantiated.
	16.	What are the advantages of OOP?
Modularity, reusability, scalability, maintainability, and abstraction.
	17.	Difference between class variable and instance variable?

	•	Class variable: Shared by all instances.
	•	Instance variable: Unique to each object.

	18.	What is multiple inheritance in Python?
A class inherits from more than one parent class.
	19.	Purpose of __str__ and __repr__ in Python?

	•	__str__: For readable string (used by print()).
	•	__repr__: For unambiguous representation (for developers/debugging).

	20.	Significance of super() in Python?
Calls a method from the parent class, often used to initialize it.
	21.	Significance of __del__ method in Python?
Destructor method called when an object is deleted; used for cleanup.
	22.	Difference between @staticmethod and @classmethod?

	•	@staticmethod: No self or cls; behaves like a regular function.
	•	@classmethod: Accesses class-level data via cls.

	23.	How does polymorphism work in Python with inheritance?
Subclasses override parent methods; objects respond differently to the same method.
	24.	What is method chaining in Python OOP?
Calling multiple methods on the same object in one line using return self.
	25.	Purpose of __call__ method in Python?
Makes an object callable like a function using object() syntax.
"""

class Animal:
    def speak(self):
        print("Some generic animal sound.")

class Dog(Animal):
    def speak(self):
        print("Bark!")

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

"""class Vehicle:
    def __init__(self, vehicle_type):
        self.vehicle_type = vehicle_type

class Car(Vehicle):
    def __init__(self, vehicle_type, brand):
        super().__init__(vehicle_type)
        self.brand = brand

class ElectricCar(Car):
    def __init__(self, vehicle_type, brand, battery):
        super().__init__(vehicle_type, brand)
        self.battery = battery

"""

class Bird:
    def fly(self):
        print("Bird is flying.")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies high.")

class Penguin(Bird):
    def fly(self):
        print("Penguin can't fly.")

class BankAccount:
    def __init__(self, balance=0):
        self.__balance = balance

    def deposit(self, amount):
        self.__balance += amount

    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
        else:
            print("Insufficient balance.")

    def check_balance(self):
        return self.__balance

class Instrument:
    def play(self):
        print("Playing an instrument.")

class Guitar(Instrument):
    def play(self):
        print("Strumming the guitar.")

class Piano(Instrument):
    def play(self):
        print("Playing the piano.")

class MathOperations:
    @classmethod
    def add_numbers(cls, a, b):
        return a + b

    @staticmethod
    def subtract_numbers(a, b):
        return a - b

class Person:
    count = 0

    def __init__(self):
        Person.count += 1

    @classmethod
    def total_persons(cls):
        return cls.count

class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."

class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades

    def average_grade(self):
        return sum(self.grades) / len(self.grades)

class Rectangle:
    def set_dimensions(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

class Employee:
    def __init__(self, hours, rate):
        self.hours = hours
        self.rate = rate

    def calculate_salary(self):
        return self.hours * self.rate

class Manager(Employee):
    def __init__(self, hours, rate, bonus):
        super().__init__(hours, rate)
        self.bonus = bonus

    def calculate_salary(self):
        return super().calculate_salary() + self.bonus

class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total_price(self):
        return self.price * self.quantity

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        return "Moo"

class Sheep(Animal):
    def sound(self):
        return "Baa"

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        return "Moo"

class Sheep(Animal):
    def sound(self):
        return "Baa"

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        return "Moo"

class Sheep(Animal):
    def sound(self):
        return "Baa"